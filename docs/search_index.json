[
["index.html", "Benchmarking the DelayedMatrixStats package Chapter 1 Introduction 1.1 Session info", " Benchmarking the DelayedMatrixStats package Peter Hickey 2017-06-09 Chapter 1 Introduction The DelayedArray package defines the DelayedMatrix class, for wrapping matrix-like objects to provide a unified interface. Wrapping an matrix-like object (typically an on-disk object) in a DelayedMatrix object allows one to perform common matrix operations on it without loading the object in memory. In order to reduce memory usage and optimize performance, operations on the object are either delayed or executed using a block processing mechanism (see ?DelayedArray::DelayedMatrix for further details) A big advantage of this is we can use choose different matrix “backends” for storing the data while preserving a common interface. Examples of backends and data they are tailored towards using are given below: Class Package Type of data Example matrix base Dense matrix RNA-seq counts matrix dgCMatrix Matrix Sparse data Single-cell RNA-seq counts matrix HDF5Matrix HDF5Array Dense matrix too large for memory Non-CpG methylation RleArray DelayedArray Data with runs of identical values Sequencing coverage 1.1 Session info The R session information when compiling this book is shown below: devtools::session_info() #&gt; setting value #&gt; version R version 3.4.0 (2017-04-21) #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_AU.UTF-8 #&gt; tz America/New_York #&gt; date 2017-06-09 #&gt; #&gt; package * version date source #&gt; backports 1.1.0 2017-05-22 CRAN (R 3.4.0) #&gt; base * 3.4.0 2017-04-21 local #&gt; BiocStyle 2.5.1 2017-05-27 Bioconductor #&gt; bookdown 0.4 2017-06-04 Github (rstudio/bookdown@fdd68e4) #&gt; compiler 3.4.0 2017-04-21 local #&gt; datasets * 3.4.0 2017-04-21 local #&gt; devtools 1.13.2 2017-06-02 CRAN (R 3.4.0) #&gt; digest 0.6.12 2017-01-27 CRAN (R 3.4.0) #&gt; evaluate 0.10 2016-10-11 CRAN (R 3.4.0) #&gt; fortunes 1.5-4 2016-12-29 CRAN (R 3.4.0) #&gt; graphics * 3.4.0 2017-04-21 local #&gt; grDevices * 3.4.0 2017-04-21 local #&gt; htmltools 0.3.6 2017-04-28 CRAN (R 3.4.0) #&gt; knitr 1.16 2017-05-18 CRAN (R 3.4.0) #&gt; magrittr 1.5 2014-11-22 CRAN (R 3.4.0) #&gt; memoise 1.1.0 2017-05-26 Github (hadley/memoise@e372cde) #&gt; methods * 3.4.0 2017-04-21 local #&gt; Rcpp 0.12.11 2017-05-22 CRAN (R 3.4.0) #&gt; rmarkdown 1.5 2017-04-26 CRAN (R 3.4.0) #&gt; rprojroot 1.2 2017-01-16 CRAN (R 3.4.0) #&gt; rstudioapi 0.6 2016-06-27 CRAN (R 3.4.0) #&gt; stats * 3.4.0 2017-04-21 local #&gt; stringi 1.1.5 2017-04-07 CRAN (R 3.4.0) #&gt; stringr 1.2.0 2017-02-18 CRAN (R 3.4.0) #&gt; tools 3.4.0 2017-04-21 local #&gt; utils * 3.4.0 2017-04-21 local #&gt; withr 1.0.2 2016-06-20 CRAN (R 3.4.0) #&gt; yaml 2.1.14 2016-11-12 CRAN (R 3.4.0) "],
["test-data.html", "Chapter 2 Test data 2.1 Measuring performance", " Chapter 2 Test data We will benchmark the DelayedMatrixStats package using different types of matrix-like data: dense_matrix: A dense matrix with 600 columns and 20000 rows (91.6 Mb) sparse_matrix: A sparse dgcMatrix with 600 columns and 20000 rows where 60% of entries are zero (54.9 Mb) rle_matrix: An run-length encoded column RleMatrix with 6 columns and 2000000 rows (0.5 Mb) library(DelayedMatrixStats) library(Matrix) library(HDF5Array) # Dense matrix dense_matrix &lt;- DelayedArray(matrix(runif(20000 * 600), nrow = 20000, ncol = 600)) dense_matrix #&gt; DelayedMatrix object of 20000 x 600 doubles: #&gt; [,1] [,2] [,3] ... [,599] [,600] #&gt; [1,] 0.99454529 0.46648761 0.87118407 . 0.03498089 0.08406800 #&gt; [2,] 0.20633296 0.87447961 0.47569619 . 0.50416338 0.71845883 #&gt; [3,] 0.36938076 0.13619145 0.01410702 . 0.14657467 0.19715968 #&gt; [4,] 0.45774410 0.79708235 0.50938715 . 0.77635399 0.18389799 #&gt; [5,] 0.09994652 0.62287144 0.68057634 . 0.30484684 0.24335585 #&gt; ... . . . . . . #&gt; [19996,] 0.88809014 0.79182716 0.67861452 . 0.6265261 0.9921975 #&gt; [19997,] 0.67529658 0.95800657 0.34794065 . 0.6424397 0.4388589 #&gt; [19998,] 0.34732867 0.06757712 0.22011501 . 0.9819295 0.3463668 #&gt; [19999,] 0.56930343 0.04110565 0.41527572 . 0.3618444 0.7961651 #&gt; [20000,] 0.77520091 0.14918206 0.30678274 . 0.4208040 0.5726051 # 60% zero elements sparse_matrix &lt;- seed(dense_matrix) zero_idx &lt;- sample(length(sparse_matrix), 0.6 * length(sparse_matrix)) sparse_matrix[zero_idx] &lt;- 0 sparse_matrix &lt;- DelayedArray(Matrix::Matrix(sparse_matrix, sparse = TRUE)) sparse_matrix #&gt; DelayedMatrix object of 20000 x 600 doubles: #&gt; [,1] [,2] [,3] ... [,599] [,600] #&gt; [1,] 0.00000000 0.46648761 0.87118407 . 0.03498089 0.08406800 #&gt; [2,] 0.20633296 0.00000000 0.47569619 . 0.50416338 0.00000000 #&gt; [3,] 0.00000000 0.00000000 0.00000000 . 0.14657467 0.19715968 #&gt; [4,] 0.45774410 0.79708235 0.00000000 . 0.00000000 0.00000000 #&gt; [5,] 0.09994652 0.62287144 0.00000000 . 0.00000000 0.00000000 #&gt; ... . . . . . . #&gt; [19996,] 0.88809014 0.00000000 0.00000000 . 0.6265261 0.9921975 #&gt; [19997,] 0.67529658 0.95800657 0.00000000 . 0.0000000 0.0000000 #&gt; [19998,] 0.34732867 0.06757712 0.22011501 . 0.9819295 0.3463668 #&gt; [19999,] 0.00000000 0.04110565 0.00000000 . 0.3618444 0.0000000 #&gt; [20000,] 0.00000000 0.00000000 0.00000000 . 0.0000000 0.0000000 # HDF5-backed dense matrix # hdf5_matrix &lt;- as(dense_matrix, &quot;HDF5Array&quot;) # Run-length encoded column matrix rle_matrix &lt;- RleArray(Rle(sample(2L, 200000 * 6 / 10, replace = TRUE), 100), dim = c(2000000, 6)) rle_matrix #&gt; RleMatrix object of 2000000 x 6 integers: #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 1 2 2 1 2 2 #&gt; [2,] 1 2 2 1 2 2 #&gt; [3,] 1 2 2 1 2 2 #&gt; [4,] 1 2 2 1 2 2 #&gt; [5,] 1 2 2 1 2 2 #&gt; ... . . . . . . #&gt; [1999996,] 2 1 2 1 1 1 #&gt; [1999997,] 2 1 2 1 1 1 #&gt; [1999998,] 2 1 2 1 1 1 #&gt; [1999999,] 2 1 2 1 1 1 #&gt; [2000000,] 2 1 2 1 1 1 Obviously, this is not a comprehensive set of inputs. Rather, it chosen to be somewhat representative of some typical genomics data. 2.1 Measuring performance Timings are measured using the microbenchmark package using 10 repetitions (times). Memory allocations are reported using the profmem package. library(microbenchmark) library(profmem) times &lt;- 10 "],
["colsums2.html", "Chapter 3 colSums2() 3.1 Pristine DelayedMatrix 3.2 With row subsetting 3.3 With column subsetting 3.4 With row and column subsetting 3.5 With delayed ops 3.6 Summary", " Chapter 3 colSums2() We compare the DelayedArray::colSums() method, which uses the block-processing algorithm, to the DelayedMatrixStats::colSums2() method, which uses tailored algorithms depending on the seed of the DelayedMatrix, as well as comparing to the colSums2() method that acts directly on the seed of the DelayedMatrix object1 3.1 Pristine DelayedMatrix microbenchmark(DelayedArray::colSums(dense_matrix), DelayedMatrixStats::colSums2(dense_matrix), DelayedMatrixStats::colSums2(seed(dense_matrix)), matrixStats::colSums2(seed(dense_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix) 1372.62806 1413.69096 #&gt; DelayedMatrixStats::colSums2(dense_matrix) 14.01136 14.58251 #&gt; DelayedMatrixStats::colSums2(seed(dense_matrix)) 13.56192 14.23526 #&gt; matrixStats::colSums2(seed(dense_matrix)) 12.75358 13.55193 #&gt; mean median uq max neval #&gt; 1535.64806 1528.76268 1565.88300 1883.48125 10 #&gt; 17.44231 15.61613 19.55338 26.34544 10 #&gt; 24.44984 14.67078 16.29124 65.17926 10 #&gt; 21.35598 15.04989 16.57927 59.50204 10 total(profmem(DelayedArray::colSums(dense_matrix))) #&gt; [1] 2498171088 total(profmem(DelayedMatrixStats::colSums2(dense_matrix))) #&gt; [1] 165512 microbenchmark(DelayedArray::colSums(sparse_matrix), DelayedMatrixStats::colSums2(sparse_matrix), DelayedMatrixStats::colSums2(seed(sparse_matrix)), Matrix::colSums(seed(sparse_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix) 1178.427799 1207.746887 #&gt; DelayedMatrixStats::colSums2(sparse_matrix) 12.257149 13.555155 #&gt; DelayedMatrixStats::colSums2(seed(sparse_matrix)) 10.200749 10.872538 #&gt; Matrix::colSums(seed(sparse_matrix)) 9.632101 9.862324 #&gt; mean median uq max neval #&gt; 1357.79906 1347.20281 1454.17409 1704.23016 10 #&gt; 14.17737 14.23011 14.84083 15.67269 10 #&gt; 11.76606 11.52069 12.58772 13.83805 10 #&gt; 10.74287 10.03771 11.01849 14.75328 10 total(profmem(DelayedArray::colSums(sparse_matrix))) #&gt; [1] 1709267496 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix))) #&gt; [1] 5464 microbenchmark(DelayedArray::colSums(rle_matrix), DelayedMatrixStats::colSums2(rle_matrix), DelayedMatrixStats::colSums2(seed(rle_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix) 1284.450239 1300.029780 #&gt; DelayedMatrixStats::colSums2(rle_matrix) 4.098852 4.309192 #&gt; DelayedMatrixStats::colSums2(seed(rle_matrix)) 2.683403 2.881191 #&gt; mean median uq max neval #&gt; 1421.415066 1331.069420 1450.043244 2041.826413 10 #&gt; 9.924347 4.425893 6.310903 49.046398 10 #&gt; 3.531750 3.526952 4.147075 4.344404 10 total(profmem(DelayedArray::colSums(rle_matrix))) #&gt; [1] 594948680 total(profmem(DelayedMatrixStats::colSums2(rle_matrix))) #&gt; [1] 1872 3.2 With row subsetting i &lt;- sample(nrow(dense_matrix), nrow(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[i, ]), DelayedMatrixStats::colSums2(dense_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix[i, ]) 196.43436 198.84777 #&gt; DelayedMatrixStats::colSums2(dense_matrix, rows = i) 14.02886 14.43554 #&gt; mean median uq max neval #&gt; 233.53941 217.23884 250.11575 352.39204 10 #&gt; 15.76242 14.96629 15.37948 24.26252 10 total(profmem(DelayedArray::colSums(dense_matrix[i, ]))) #&gt; [1] 326614368 total(profmem(DelayedMatrixStats::colSums2(dense_matrix, rows = i))) #&gt; [1] 21512 microbenchmark(DelayedArray::colSums(sparse_matrix[i, ]), DelayedMatrixStats::colSums2(sparse_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix[i, ]) 184.17311 205.58022 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, rows = i) 44.54429 45.56571 #&gt; mean median uq max neval #&gt; 248.18029 236.1196 296.25290 352.87500 10 #&gt; 54.94194 51.4051 57.99285 90.30193 10 total(profmem(DelayedArray::colSums(sparse_matrix[i, ]))) #&gt; [1] 217293904 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix, rows = i))) #&gt; [1] 5802096 i &lt;- sample(nrow(rle_matrix), nrow(rle_matrix) / 10) microbenchmark(DelayedArray::colSums(rle_matrix[i, ]), DelayedMatrixStats::colSums2(rle_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix[i, ]) 140.2176 146.4898 #&gt; DelayedMatrixStats::colSums2(rle_matrix, rows = i) 2478.7272 2590.4027 #&gt; mean median uq max neval #&gt; 173.989 177.2696 188.9324 220.4917 10 #&gt; 2652.891 2637.0296 2705.3154 2842.0197 10 total(profmem(DelayedArray::colSums(rle_matrix[i, ]))) #&gt; [1] 62586936 total(profmem(DelayedMatrixStats::colSums2(rle_matrix, rows = i))) #&gt; [1] 99980704 3.3 With column subsetting j &lt;- sample(ncol(dense_matrix), ncol(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[, j]), DelayedMatrixStats::colSums2(dense_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(dense_matrix[, j]) 144.001503 #&gt; DelayedMatrixStats::colSums2(dense_matrix, cols = j) 3.403522 #&gt; lq mean median uq max neval #&gt; 158.218201 179.577895 165.482901 170.935082 298.404129 10 #&gt; 3.546942 4.048916 3.853625 4.638388 4.814978 10 total(profmem(DelayedArray::colSums(dense_matrix[, j]))) #&gt; [1] 326835928 total(profmem(DelayedMatrixStats::colSums2(dense_matrix, cols = j))) #&gt; [1] 161192 microbenchmark(DelayedArray::colSums(sparse_matrix[, j]), DelayedMatrixStats::colSums2(sparse_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix[, j]) 140.05857 160.16211 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, cols = j) 12.56083 13.28289 #&gt; mean median uq max neval #&gt; 177.8104 175.3931 183.49108 245.73732 10 #&gt; 15.7835 14.2042 16.55962 24.86061 10 total(profmem(DelayedArray::colSums(sparse_matrix[, j]))) #&gt; [1] 217172248 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix, cols = j))) #&gt; [1] 5770616 j &lt;- sample(ncol(rle_matrix), ncol(rle_matrix) / 2) microbenchmark(DelayedArray::colSums(rle_matrix[, j]), DelayedMatrixStats::colSums2(rle_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix[, j]) 640.158292 648.234104 #&gt; DelayedMatrixStats::colSums2(rle_matrix, cols = j) 3.789984 4.062042 #&gt; mean median uq max neval #&gt; 669.924460 662.49662 679.354278 724.901950 10 #&gt; 4.469771 4.27734 4.725525 5.678389 10 total(profmem(DelayedArray::colSums(rle_matrix[, j]))) #&gt; [1] 305477264 total(profmem(DelayedMatrixStats::colSums2(rle_matrix, cols = j))) #&gt; [1] 1872 3.4 With row and column subsetting i &lt;- sample(nrow(dense_matrix), nrow(dense_matrix) / 10) j &lt;- sample(ncol(dense_matrix), ncol(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[i, j]), DelayedMatrixStats::colSums2(dense_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(dense_matrix[i, j]) 38.318997 #&gt; DelayedMatrixStats::colSums2(dense_matrix, rows = i, cols = j) 3.097168 #&gt; lq mean median uq max neval #&gt; 39.760973 72.702570 61.045170 76.261997 212.543833 10 #&gt; 3.279971 3.814565 3.713833 4.586598 4.642231 10 microbenchmark(DelayedArray::colSums(sparse_matrix[i, j]), DelayedMatrixStats::colSums2(sparse_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(sparse_matrix[i, j]) 61.59450 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, rows = i, cols = j) 42.37626 #&gt; lq mean median uq max neval #&gt; 66.65260 75.01312 67.53065 71.16133 113.7171 10 #&gt; 47.27844 58.05934 52.11927 55.57983 124.6849 10 i &lt;- sample(nrow(rle_matrix), nrow(rle_matrix) / 10) j &lt;- sample(ncol(rle_matrix), ncol(rle_matrix) / 2) microbenchmark(DelayedArray::colSums(rle_matrix[i, j]), DelayedMatrixStats::colSums2(rle_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(rle_matrix[i, j]) 74.47508 #&gt; DelayedMatrixStats::colSums2(rle_matrix, rows = i, cols = j) 1284.10942 #&gt; lq mean median uq max neval #&gt; 79.31653 83.71271 80.13897 81.42439 118.9864 10 #&gt; 1292.07481 1299.37911 1299.64036 1304.03689 1320.8351 10 3.5 With delayed ops microbenchmark(DelayedArray::colSums(dense_matrix ^ 2), DelayedMatrixStats::colSums2(dense_matrix ^ 2), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix^2) 1305.1857 1454.6109 #&gt; DelayedMatrixStats::colSums2(dense_matrix^2) 262.4106 281.9869 #&gt; mean median uq max neval #&gt; 1506.0113 1485.7034 1622.2423 1643.3722 10 #&gt; 360.0025 367.7995 440.2934 442.3388 10 microbenchmark(DelayedArray::colSums(sparse_matrix ^ 2), DelayedMatrixStats::colSums2(sparse_matrix ^ 2), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix^2) 1376.3167 1396.6207 #&gt; DelayedMatrixStats::colSums2(sparse_matrix^2) 546.9076 585.1316 #&gt; mean median uq max neval #&gt; 1501.7047 1533.1500 1589.5161 1639.3453 10 #&gt; 631.1484 617.4235 657.4039 783.6058 10 microbenchmark(DelayedArray::colSums(rle_matrix ^ 2), DelayedMatrixStats::colSums2(rle_matrix ^ 2), times = times) #&gt; Unit: seconds #&gt; expr min lq mean #&gt; DelayedArray::colSums(rle_matrix^2) 1.465638 1.484824 1.579603 #&gt; DelayedMatrixStats::colSums2(rle_matrix^2) 1.211764 1.234875 1.297082 #&gt; median uq max neval #&gt; 1.536663 1.579189 1.919716 10 #&gt; 1.288734 1.353342 1.400611 10 3.6 Summary The ‘seed method’ shouldn’t be called by the user because it does not realise delayed operations. It is used here for demonstration purposes on a “pristine” DelayedMatrix to measure the additional overhead of S4 methods↩ "],
["references.html", "References", " References "]
]
