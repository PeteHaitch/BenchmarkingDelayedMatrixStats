[
["index.html", "Benchmarking the DelayedMatrixStats package Chapter 1 Introduction 1.1 Session info", " Benchmarking the DelayedMatrixStats package Peter Hickey 2017-06-04 Chapter 1 Introduction The DelayedArray package defines the DelayedMatrix class, for wrapping matrix-like objects to provide a unified interface. Wrapping an matrix-like object (typically an on-disk object) in a DelayedMatrix object allows one to perform common matrix operations on it without loading the object in memory. In order to reduce memory usage and optimize performance, operations on the object are either delayed or executed using a block processing mechanism (see ?DelayedArray::DelayedMatrix for further details) A big advantage of this is we can use choose different matrix “backends” for storing the data while preserving a common interface. Examples of backends and data they are tailored towards using are given below: Class Package Type of data Example matrix base Dense matrix RNA-seq counts matrix dgCMatrix Matrix Sparse data Single-cell RNA-seq counts matrix HDF5Matrix HDF5Array Dense matrix too large for memory Non-CpG methylation RleArray DelayedArray Data with runs of identical values Sequencing coverage 1.1 Session info The R session information when compiling this book is shown below: devtools::session_info() #&gt; setting value #&gt; version R version 3.4.0 (2017-04-21) #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_AU.UTF-8 #&gt; tz America/New_York #&gt; date 2017-06-04 #&gt; #&gt; package * version date source #&gt; backports 1.1.0 2017-05-22 CRAN (R 3.4.0) #&gt; base * 3.4.0 2017-04-21 local #&gt; BiocStyle 2.5.1 2017-05-27 Bioconductor #&gt; bookdown 0.4 2017-06-04 Github (rstudio/bookdown@fdd68e4) #&gt; compiler 3.4.0 2017-04-21 local #&gt; datasets * 3.4.0 2017-04-21 local #&gt; devtools 1.13.2 2017-06-02 CRAN (R 3.4.0) #&gt; digest 0.6.12 2017-01-27 CRAN (R 3.4.0) #&gt; evaluate 0.10 2016-10-11 CRAN (R 3.4.0) #&gt; fortunes 1.5-4 2016-12-29 CRAN (R 3.4.0) #&gt; graphics * 3.4.0 2017-04-21 local #&gt; grDevices * 3.4.0 2017-04-21 local #&gt; htmltools 0.3.6 2017-04-28 CRAN (R 3.4.0) #&gt; knitr 1.16 2017-05-18 CRAN (R 3.4.0) #&gt; magrittr 1.5 2014-11-22 CRAN (R 3.4.0) #&gt; memoise 1.1.0 2017-05-26 Github (hadley/memoise@e372cde) #&gt; methods * 3.4.0 2017-04-21 local #&gt; Rcpp 0.12.11 2017-05-22 CRAN (R 3.4.0) #&gt; rmarkdown 1.5 2017-04-26 CRAN (R 3.4.0) #&gt; rprojroot 1.2 2017-01-16 CRAN (R 3.4.0) #&gt; rstudioapi 0.6 2016-06-27 CRAN (R 3.4.0) #&gt; stats * 3.4.0 2017-04-21 local #&gt; stringi 1.1.5 2017-04-07 CRAN (R 3.4.0) #&gt; stringr 1.2.0 2017-02-18 CRAN (R 3.4.0) #&gt; tools 3.4.0 2017-04-21 local #&gt; utils * 3.4.0 2017-04-21 local #&gt; withr 1.0.2 2016-06-20 CRAN (R 3.4.0) #&gt; yaml 2.1.14 2016-11-12 CRAN (R 3.4.0) "],
["test-data.html", "Chapter 2 Test data 2.1 Measuring performance", " Chapter 2 Test data We will benchmark the DelayedMatrixStats package using different types of matrix-like data: dense_matrix: A dense matrix with 600 columns and 20000 rows (91.6 Mb) sparse_matrix: A sparse dgcMatrix with 600 columns and 20000 rows where 60% of entries are zero (54.9 Mb) rle_matrix: An run-length encoded column RleMatrix with 6 columns and 2000000 rows (0.5 Mb) library(DelayedMatrixStats) library(Matrix) library(HDF5Array) # Dense matrix dense_matrix &lt;- DelayedArray(matrix(runif(20000 * 600), nrow = 20000, ncol = 600)) dense_matrix #&gt; DelayedMatrix object of 20000 x 600 doubles: #&gt; [,1] [,2] [,3] ... [,599] [,600] #&gt; [1,] 0.95070560 0.09865026 0.30533980 . 0.3983158 0.7015749 #&gt; [2,] 0.47510290 0.24381241 0.53119689 . 0.3706273 0.7805677 #&gt; [3,] 0.71663268 0.83190267 0.41495001 . 0.1572735 0.0622759 #&gt; [4,] 0.51031424 0.81021199 0.48288399 . 0.8817700 0.6890185 #&gt; [5,] 0.59373621 0.47584845 0.13139782 . 0.4372631 0.6115552 #&gt; ... . . . . . . #&gt; [19996,] 0.21030458 0.32417577 0.09062090 . 0.7526897 0.3351034 #&gt; [19997,] 0.91096435 0.23066307 0.79728675 . 0.3207034 0.7036122 #&gt; [19998,] 0.29748109 0.31942038 0.17291357 . 0.1814319 0.3340224 #&gt; [19999,] 0.83867138 0.27260421 0.26325607 . 0.9883146 0.3130137 #&gt; [20000,] 0.07469925 0.54643009 0.44262166 . 0.9973660 0.2112855 # 60% zero elements sparse_matrix &lt;- seed(dense_matrix) zero_idx &lt;- sample(length(sparse_matrix), 0.6 * length(sparse_matrix)) sparse_matrix[zero_idx] &lt;- 0 sparse_matrix &lt;- DelayedArray(Matrix::Matrix(sparse_matrix, sparse = TRUE)) sparse_matrix #&gt; DelayedMatrix object of 20000 x 600 doubles: #&gt; [,1] [,2] [,3] ... [,599] [,600] #&gt; [1,] 0.00000000 0.09865026 0.00000000 . 0.3983158 0.0000000 #&gt; [2,] 0.47510290 0.00000000 0.53119689 . 0.0000000 0.7805677 #&gt; [3,] 0.00000000 0.83190267 0.41495001 . 0.0000000 0.0622759 #&gt; [4,] 0.00000000 0.00000000 0.00000000 . 0.0000000 0.0000000 #&gt; [5,] 0.59373621 0.00000000 0.13139782 . 0.4372631 0.0000000 #&gt; ... . . . . . . #&gt; [19996,] 0.0000000 0.3241758 0.0000000 . 0.7526897 0.3351034 #&gt; [19997,] 0.9109644 0.2306631 0.0000000 . 0.3207034 0.7036122 #&gt; [19998,] 0.0000000 0.0000000 0.0000000 . 0.1814319 0.3340224 #&gt; [19999,] 0.0000000 0.2726042 0.2632561 . 0.9883146 0.0000000 #&gt; [20000,] 0.0000000 0.5464301 0.0000000 . 0.9973660 0.2112855 # HDF5-backed dense matrix # hdf5_matrix &lt;- as(dense_matrix, &quot;HDF5Array&quot;) # Run-length encoded column matrix rle_matrix &lt;- RleArray(Rle(sample(2L, 200000 * 6 / 10, replace = TRUE), 100), dim = c(2000000, 6)) rle_matrix #&gt; RleMatrix object of 2000000 x 6 integers: #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 2 2 1 2 2 1 #&gt; [2,] 2 2 1 2 2 1 #&gt; [3,] 2 2 1 2 2 1 #&gt; [4,] 2 2 1 2 2 1 #&gt; [5,] 2 2 1 2 2 1 #&gt; ... . . . . . . #&gt; [1999996,] 1 2 1 2 2 1 #&gt; [1999997,] 1 2 1 2 2 1 #&gt; [1999998,] 1 2 1 2 2 1 #&gt; [1999999,] 1 2 1 2 2 1 #&gt; [2000000,] 1 2 1 2 2 1 Obviously, this is not a comprehensive set of inputs. Rather, it chosen to be somewhat representative of some typical genomics data. 2.1 Measuring performance Timings are measured using the microbenchmark package using 10 repetitions (times). Memory allocations are reported using the profmem package. library(microbenchmark) library(profmem) times &lt;- 10 "],
["colsums2.html", "Chapter 3 colSums2() 3.1 Pristine DelayedMatrix 3.2 With row subsetting 3.3 With column subsetting 3.4 With row and column subsetting 3.5 With delayed ops 3.6 Summary", " Chapter 3 colSums2() We compare the DelayedArray::colSums() method, which uses the block-processing algorithm, to the DelayedMatrixStats::colSums2() method, which uses tailored algorithms depending on the seed of the DelayedMatrix and to the DelayedMatrixStats:::.colSums2() method that acts directly on the seed of the DelayedMatrix object1 3.1 Pristine DelayedMatrix microbenchmark(DelayedArray::colSums(dense_matrix), DelayedMatrixStats::colSums2(dense_matrix), DelayedMatrixStats:::.colSums2(seed(dense_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix) 1408.61567 1433.98258 #&gt; DelayedMatrixStats::colSums2(dense_matrix) 14.00580 14.50890 #&gt; DelayedMatrixStats:::.colSums2(seed(dense_matrix)) 12.75963 13.24246 #&gt; mean median uq max neval #&gt; 1515.04624 1468.59992 1550.81586 1877.00361 10 #&gt; 15.66976 15.05065 15.16516 19.91145 10 #&gt; 14.41188 14.03868 15.12447 16.97410 10 total(profmem(DelayedArray::colSums(dense_matrix))) #&gt; [1] 2498171088 total(profmem(DelayedMatrixStats::colSums2(dense_matrix))) #&gt; [1] 165512 microbenchmark(DelayedArray::colSums(sparse_matrix), DelayedMatrixStats::colSums2(sparse_matrix), DelayedMatrixStats:::.colSums2(seed(sparse_matrix)), Matrix::colSums(seed(sparse_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(sparse_matrix) 1183.847176 #&gt; DelayedMatrixStats::colSums2(sparse_matrix) 11.184205 #&gt; DelayedMatrixStats:::.colSums2(seed(sparse_matrix)) 9.793739 #&gt; Matrix::colSums(seed(sparse_matrix)) 9.850097 #&gt; lq mean median uq max neval #&gt; 1203.56868 1263.47204 1246.03850 1327.38476 1385.78481 10 #&gt; 11.27018 13.03639 13.27612 14.54941 15.45832 10 #&gt; 10.94256 11.56462 11.36510 11.94394 13.74808 10 #&gt; 10.12159 10.98836 10.55925 12.14756 12.72709 10 total(profmem(DelayedArray::colSums(sparse_matrix))) #&gt; [1] 1709267504 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix))) #&gt; [1] 5464 microbenchmark(DelayedArray::colSums(rle_matrix), DelayedMatrixStats::colSums2(rle_matrix), DelayedMatrixStats:::.colSums2(seed(rle_matrix)), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix) 2403.753261 2447.157148 #&gt; DelayedMatrixStats::colSums2(rle_matrix) 3.753334 3.767261 #&gt; DelayedMatrixStats:::.colSums2(seed(rle_matrix)) 2.697623 2.723950 #&gt; mean median uq max neval #&gt; 2502.838647 2480.543781 2563.364811 2631.490872 10 #&gt; 3.986795 3.938854 3.988843 4.708529 10 #&gt; 8.197613 2.914385 3.718004 46.153767 10 total(profmem(DelayedArray::colSums(rle_matrix))) #&gt; [1] 787412248 total(profmem(DelayedMatrixStats::colSums2(rle_matrix))) #&gt; [1] 1872 3.2 With row subsetting i &lt;- sample(nrow(dense_matrix), nrow(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[i, ]), DelayedMatrixStats::colSums2(dense_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix[i, ]) 187.48875 192.80726 #&gt; DelayedMatrixStats::colSums2(dense_matrix, rows = i) 13.49945 13.76257 #&gt; mean median uq max neval #&gt; 226.72987 195.30400 231.85423 348.03247 10 #&gt; 14.20651 14.08922 14.45145 15.72646 10 total(profmem(DelayedArray::colSums(dense_matrix[i, ]))) #&gt; [1] 326614368 total(profmem(DelayedMatrixStats::colSums2(dense_matrix, rows = i))) #&gt; [1] 21512 microbenchmark(DelayedArray::colSums(sparse_matrix[i, ]), DelayedMatrixStats::colSums2(sparse_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix[i, ]) 188.74200 193.95678 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, rows = i) 44.11033 44.67383 #&gt; mean median uq max neval #&gt; 207.15558 208.61591 219.32978 227.67523 10 #&gt; 48.45741 47.51677 48.57594 58.05766 10 total(profmem(DelayedArray::colSums(sparse_matrix[i, ]))) #&gt; [1] 217286848 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix, rows = i))) #&gt; [1] 5795040 i &lt;- sample(nrow(rle_matrix), nrow(rle_matrix) / 10) microbenchmark(DelayedArray::colSums(rle_matrix[i, ]), DelayedMatrixStats::colSums2(rle_matrix, rows = i), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix[i, ]) 265.1415 281.9165 #&gt; DelayedMatrixStats::colSums2(rle_matrix, rows = i) 2521.6969 2530.8499 #&gt; mean median uq max neval #&gt; 295.5994 288.7689 318.6109 329.836 10 #&gt; 2564.1160 2556.6985 2575.4062 2685.863 10 total(profmem(DelayedArray::colSums(rle_matrix[i, ]))) #&gt; [1] 86581048 total(profmem(DelayedMatrixStats::colSums2(rle_matrix, rows = i))) #&gt; [1] 99980704 3.3 With column subsetting j &lt;- sample(ncol(dense_matrix), ncol(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[, j]), DelayedMatrixStats::colSums2(dense_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(dense_matrix[, j]) 160.602091 #&gt; DelayedMatrixStats::colSums2(dense_matrix, cols = j) 2.846538 #&gt; lq mean median uq max neval #&gt; 163.752830 189.342436 165.306212 204.669825 327.949654 10 #&gt; 3.031495 3.212337 3.124543 3.189582 4.017612 10 total(profmem(DelayedArray::colSums(dense_matrix[, j]))) #&gt; [1] 326835928 total(profmem(DelayedMatrixStats::colSums2(dense_matrix, cols = j))) #&gt; [1] 161192 microbenchmark(DelayedArray::colSums(sparse_matrix[, j]), DelayedMatrixStats::colSums2(sparse_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix[, j]) 162.11769 174.45367 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, cols = j) 10.76092 12.58258 #&gt; mean median uq max neval #&gt; 197.77123 178.79578 203.35623 328.86511 10 #&gt; 13.34045 13.34616 14.48577 14.64604 10 total(profmem(DelayedArray::colSums(sparse_matrix[, j]))) #&gt; [1] 217160744 total(profmem(DelayedMatrixStats::colSums2(sparse_matrix, cols = j))) #&gt; [1] 5759104 j &lt;- sample(ncol(rle_matrix), ncol(rle_matrix) / 2) microbenchmark(DelayedArray::colSums(rle_matrix[, j]), DelayedMatrixStats::colSums2(rle_matrix, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(rle_matrix[, j]) 1206.04993 1229.242478 #&gt; DelayedMatrixStats::colSums2(rle_matrix, cols = j) 3.56065 3.856014 #&gt; mean median uq max neval #&gt; 1254.683014 1250.18800 1277.53525 1317.428964 10 #&gt; 3.956366 3.93841 4.16998 4.431168 10 total(profmem(DelayedArray::colSums(rle_matrix[, j]))) #&gt; [1] 401708120 total(profmem(DelayedMatrixStats::colSums2(rle_matrix, cols = j))) #&gt; [1] 1872 3.4 With row and column subsetting i &lt;- sample(nrow(dense_matrix), nrow(dense_matrix) / 10) j &lt;- sample(ncol(dense_matrix), ncol(dense_matrix) / 10) microbenchmark(DelayedArray::colSums(dense_matrix[i, j]), DelayedMatrixStats::colSums2(dense_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(dense_matrix[i, j]) 38.16495 #&gt; DelayedMatrixStats::colSums2(dense_matrix, rows = i, cols = j) 2.45432 #&gt; lq mean median uq max neval #&gt; 42.814124 71.53257 62.697789 68.861067 210.056720 10 #&gt; 2.504864 2.79146 2.552467 2.703125 4.614551 10 microbenchmark(DelayedArray::colSums(sparse_matrix[i, j]), DelayedMatrixStats::colSums2(sparse_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(sparse_matrix[i, j]) 46.49547 #&gt; DelayedMatrixStats::colSums2(sparse_matrix, rows = i, cols = j) 42.05782 #&gt; lq mean median uq max neval #&gt; 61.82952 62.85905 63.41717 65.98138 85.79071 10 #&gt; 44.16492 53.69229 46.26637 48.85194 119.13561 10 i &lt;- sample(nrow(rle_matrix), nrow(rle_matrix) / 10) j &lt;- sample(ncol(rle_matrix), ncol(rle_matrix) / 2) microbenchmark(DelayedArray::colSums(rle_matrix[i, j]), DelayedMatrixStats::colSums2(rle_matrix, rows = i, cols = j), times = times) #&gt; Unit: milliseconds #&gt; expr min #&gt; DelayedArray::colSums(rle_matrix[i, j]) 145.6185 #&gt; DelayedMatrixStats::colSums2(rle_matrix, rows = i, cols = j) 1255.3213 #&gt; lq mean median uq max neval #&gt; 149.0024 158.6695 150.1652 179.6876 184.4764 10 #&gt; 1268.5583 1287.6573 1286.5773 1302.5283 1331.8413 10 3.5 With delayed ops microbenchmark(DelayedArray::colSums(dense_matrix ^ 2), DelayedMatrixStats::colSums2(dense_matrix ^ 2), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(dense_matrix^2) 1316.7381 1442.1117 #&gt; DelayedMatrixStats::colSums2(dense_matrix^2) 266.3058 280.9153 #&gt; mean median uq max neval #&gt; 1459.9733 1474.6550 1496.8039 1587.6119 10 #&gt; 387.4722 417.6813 447.7697 472.5307 10 microbenchmark(DelayedArray::colSums(sparse_matrix ^ 2), DelayedMatrixStats::colSums2(sparse_matrix ^ 2), times = times) #&gt; Unit: milliseconds #&gt; expr min lq #&gt; DelayedArray::colSums(sparse_matrix^2) 1264.0716 1363.074 #&gt; DelayedMatrixStats::colSums2(sparse_matrix^2) 529.0654 542.983 #&gt; mean median uq max neval #&gt; 1478.3990 1456.5185 1578.1508 1769.6818 10 #&gt; 578.2613 550.6886 646.3959 656.6858 10 microbenchmark(DelayedArray::colSums(rle_matrix ^ 2), DelayedMatrixStats::colSums2(rle_matrix ^ 2), times = times) #&gt; Unit: seconds #&gt; expr min lq mean #&gt; DelayedArray::colSums(rle_matrix^2) 2.666107 2.673326 2.766047 #&gt; DelayedMatrixStats::colSums2(rle_matrix^2) 2.321411 2.408761 2.498563 #&gt; median uq max neval #&gt; 2.724920 2.838986 2.970594 10 #&gt; 2.514786 2.579666 2.658754 10 3.6 Summary DelayedMatrixStats:::.colSums2() shouldn’t be called by the user because it does not realise delayed operations. It is used here for demonstration purposes on a “pristine” DelayedMatrix to measure the additional overhead of S4 methods↩ "],
["references.html", "References", " References "]
]
